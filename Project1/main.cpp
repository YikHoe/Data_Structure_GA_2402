// Project1.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <chrono>
#include <iomanip>
#include "LinkedList.h"
#include "FileHandler.h"


using namespace std;
using namespace std::chrono;

struct Summary {
    int totalPositive = 0;
    int totalNeutral = 0;
    int totalNegative = 0;
    int totalMatching = 0;
    int totalUnmatch = 0;
    int totalReviews = 0;
};

void tokenize(string review, LinkedList& list) {
    string word = "";
    for (char c : review) {
        // Manually check if the character is alphanumeric
        if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
            // Manually convert to lowercase if it's an uppercase letter
            if (c >= 'A' && c <= 'Z') {
                c = c + 32; // Convert to lowercase by adding ASCII offset
            }
            word += c;
        }
        else {
            if (!word.empty()) {
                list.insertFront(word);
                word = "";
            }
        }
    }

    if (!word.empty()) {
        list.insertFront(word);
    }
}

int calculateSentimentScore(int positiveCount, int negativeCount) {
    int N = positiveCount + negativeCount;
    int rawScore = positiveCount - negativeCount;
    int minRawScore = -N;
    int maxRawScore = N;

    if (maxRawScore == minRawScore) return 3;

    float normalizedScore = float(rawScore - minRawScore) / (maxRawScore - minRawScore);
    return round(1.0f + (4.0f * normalizedScore));
}

// compare sentimental score and the rating given
void analyzeScore(int sentimentScore, int ratingGiven, Summary& summary) {
    string result = (sentimentScore != ratingGiven) ? "does not match" : "matches";
    string consistency = (sentimentScore != ratingGiven) ? "inconsistency" : "consistency";

    // Update summary based on sentiment score and user rating
    if (sentimentScore == ratingGiven) {
        summary.totalMatching++;
    }
    else {
        summary.totalUnmatch++;
    }

    switch (sentimentScore) {
    case 1:
    case 2:  // When the round score is 1-2
        summary.totalNegative++;
        break;  // Break ensures the next case doesn't execute

    case 3:
        summary.totalNeutral++;
        break;

    case 4:
    case 5:  // When the round score is 4-5
        summary.totalPositive++;
        break;

    default:
        // Handle unexpected values of roundScore
        break;
    }


    cout << "User's subjective evaluation " << result << " the sentiment score provided by the analysis. "
        << "There is a " << consistency << " between the sentiment score generated by the analysis and the user's evaluation of the sentiment."
        << endl << endl;
}

void displayCount(int reviewCount, int totalPositiveCount, int totalNegativeCount, LinkedList& accumulatedWordList) {
    cout << "Total Reviews Processed = " << reviewCount << endl;
    cout << "Total Count of Positive Words = " << totalPositiveCount << endl;
    cout << "Total Count of Negative Words = " << totalNegativeCount << endl;
    cout << "Full Word List (from all reviews, sorted by frequency):" << endl;
    accumulatedWordList.printReport();
}

void displayFinalSummary(const Summary& summary) {
    std::cout << "----------------------------------Final Summary----------------------------------" << endl;
    std::cout << "Total Positive Review       : " << summary.totalPositive << endl;
    std::cout << "Total Neutral Review        : " << summary.totalNeutral << endl;
    std::cout << "Total Negative Review       : " << summary.totalNegative << endl;
    std::cout << "Total Matching Review       : " << summary.totalMatching << endl;
    std::cout << "Total Unmatch Review        : " << summary.totalUnmatch << endl;
    std::cout << "Total Review                : " << summary.totalReviews << endl;


    // Calculate and display overall evaluation accuracy
    if (summary.totalReviews > 0) {
		double totalMatched = summary.totalMatching * 1.0;
		double allReviews = summary.totalReviews * 1.0;
        double overallAccuracy = (totalMatched / allReviews) * 100.0;
        cout << fixed << setprecision(2); // Set precision for percentage display
        cout << "Overall Evaluation Accuracy  : " << overallAccuracy << "%" << std::endl;
    }
    else {
        std::cout << "Overall Evaluation Accuracy  : N/A" << std::endl;
    }
}

// WONG YI ZUN (merge sort + linear search)
void processReviewsAlgo1(LinkedList& reviewsList, LinkedList& positiveList, LinkedList& negativeList, Summary& summary) {
	LinkedList wordList, accumulatedWordList;
	int totalPositiveCount = 0, totalNegativeCount = 0, reviewCount = 0;
	auto totalSearchTime = duration_cast<microseconds>(milliseconds(0)); // Initialize to 0

	for (Node* currentReviewNode = reviewsList.getHead(); currentReviewNode != nullptr; currentReviewNode = currentReviewNode->nextAddress) {
		LinkedList foundPositiveList, foundNegativeList;
		int positiveCount = 0, negativeCount = 0;
		reviewCount++;

		cout << "Review " << reviewCount << ": " << currentReviewNode->review << endl;
		cout << string(120, '=') << endl;

		tokenize(currentReviewNode->review, wordList);
		LinkedList foundedList = wordList.findMatchingWords(positiveList, negativeList);

		// Timer for search algorithm
		auto searchStartTime = high_resolution_clock::now();

		for (WordNode* currentWord = foundedList.getWordHead(); currentWord != nullptr; currentWord = currentWord->nextAddress) {
			if (positiveList.linearSearch(currentWord->word)) {
				foundPositiveList.checkDuped(currentWord->word);
				positiveCount++;
			}
			else {
				foundNegativeList.checkDuped(currentWord->word);
				negativeCount++;
			}
			accumulatedWordList.checkDuped(currentWord->word);
		}

		auto searchEndTime = high_resolution_clock::now();
		auto searchDuration = duration_cast<microseconds>(searchEndTime - searchStartTime);
		cout << "Time taken for search: " << searchDuration.count() / 1'000'000.0 << " seconds." << endl;
		totalSearchTime += searchDuration;

		cout << positiveCount << " Positive words found:" << endl;
		foundPositiveList.displayList();

		cout << negativeCount << " Negative words found:" << endl;
		foundNegativeList.displayList();

		totalPositiveCount += positiveCount;
		totalNegativeCount += negativeCount;

		int sentimentScore = calculateSentimentScore(positiveCount, negativeCount);
		cout << "Sentiment Score (1-5) = " << sentimentScore << endl;
		cout << "Rating given by User =  " << currentReviewNode->rating << endl;
		analyzeScore(sentimentScore, stoi(currentReviewNode->rating), summary);

		wordList = LinkedList();
	}
	summary.totalReviews = reviewCount;

	// Timer for sort algorithm
	auto sortStartTime = high_resolution_clock::now();

	accumulatedWordList.sortByFrequency(); // Assuming this is where sorting happens

	auto sortEndTime = high_resolution_clock::now();
	auto sortDuration = duration_cast<microseconds>(sortEndTime - sortStartTime);

	displayCount(reviewCount, totalPositiveCount, totalNegativeCount, accumulatedWordList);
	cout << "Time taken for all search: " << totalSearchTime.count() / 1'000'000.0 << " seconds." << endl;
	cout << "Time taken for sorting: " << sortDuration.count() / 1'000'000.0 << " seconds." << endl;
	accumulatedWordList.linearFindmax();
	accumulatedWordList.linearFindmin();
	displayFinalSummary(summary);
}

// AU YIK HOE (quick sort + binary search)
void processReviewsAlgo2(LinkedList& reviews, LinkedList& positiveList, LinkedList& negativeList, Summary& summary) {
    LinkedList accumulatedWordList;
    int totalPositiveCount = 0, totalNegativeCount = 0, reviewCount = 0;
    auto totalSearchTime = duration_cast<microseconds>(milliseconds(0)); // Initialize to 0

    for (Node* currentReviewNode = reviews.getHead(); currentReviewNode != nullptr; currentReviewNode = currentReviewNode->nextAddress) {
        LinkedList wordList;

        cout << endl << string(100, '=') << endl;
        cout << "Review " << reviewCount << ": " << currentReviewNode->review << endl << endl;
        tokenize(currentReviewNode->review, wordList);

        int positiveCount = 0;
        int negativeCount = 0;

        auto searchStartTime = high_resolution_clock::now();

        for (WordNode* tempWord = wordList.getWordHead(); tempWord != nullptr; tempWord = tempWord->nextAddress) {
            if (positiveList.binarySearch(tempWord->word)) {
                positiveCount++;
                totalPositiveCount++;
                accumulatedWordList.checkDuped(tempWord->word);
            }

            if (negativeList.binarySearch(tempWord->word)) {
                negativeCount++;
                totalNegativeCount++;
                accumulatedWordList.checkDuped(tempWord->word);
            }
        }

        auto searchEndTime = high_resolution_clock::now();
        auto searchDuration = duration_cast<microseconds>(searchEndTime - searchStartTime);
        cout << "Time taken for search: " << searchDuration.count() / 1'000'000.0 << " seconds." << endl;
        totalSearchTime += searchDuration;

        // Display analysis result for current review
        // Positive words found
        cout << positiveCount << " postive words found in the review: " << endl;
        positiveList.printReport();

        // Negative words found
        cout << negativeCount << " negative words found in the review: " << endl;
        negativeList.printReport();

        // Calculate sentimental score based on total positive words and negative words found in review
        int sentimentScore = calculateSentimentScore(positiveCount, negativeCount);
        cout << "Sentiment Score (1-5) = " << sentimentScore << endl;
        cout << "Rating given by User =  " << currentReviewNode->rating << endl;

        // analyze rating of review
        analyzeScore(sentimentScore, stoi(currentReviewNode->rating), summary);
        cout << endl << string(100, '=') << endl;

        positiveList.resetFrequencies();
        negativeList.resetFrequencies();
        reviewCount++;;
    }

    summary.totalReviews = reviewCount;

    // Timer for sort algorithm
    auto sortStartTime = high_resolution_clock::now();

    accumulatedWordList.quickSortByFrequency(); // Assuming this is where sorting happens

    auto sortEndTime = high_resolution_clock::now();
    auto sortDuration = duration_cast<microseconds>(sortEndTime - sortStartTime);

    displayCount(reviewCount, totalPositiveCount, totalNegativeCount, accumulatedWordList);
    accumulatedWordList.binaryFindMin();
    accumulatedWordList.binaryFindMax();

    displayFinalSummary(summary);

    cout << "Time taken for all search: " << totalSearchTime.count() / 1'000'000.0 << " seconds." << endl;
    cout << "Time taken for sorting: " << sortDuration.count() / 1'000'000.0 << " seconds." << endl;
}

int main() {
	LinkedList reviewsList, positiveList, negativeList;
	Summary summary;

	readReviewsFromCSV("tripadvisor_hotel_reviews.csv", reviewsList);
	readWordFromText("positive-words.txt", positiveList);
	readWordFromText("negative-words.txt", negativeList);

	auto startTime = high_resolution_clock::now();

	//processReviewsAlgo1(reviewsList, positiveList, negativeList, summary); // Linked List algorithm 1 (merge + linear)
	processReviewsAlgo2(reviewsList, positiveList, negativeList, summary); // Linled List algorithm 2 (quick + binary)

	auto endTime = high_resolution_clock::now();
	auto duration = duration_cast<microseconds>(endTime - startTime);

	cout << "Time taken: " << duration.count() / 1'000'000 / 60 << " minutes and "
		<< (duration.count() / 1'000'000) % 60 << " seconds." << endl;

	return 0;
}




// Project1.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include "LinkedList.h"
#include "FileHandler.h"
#include <chrono>
#include <iomanip>


using namespace std;
using namespace std::chrono;

struct Summary {
	int totalPositive = 0;
	int totalNeutral = 0;
	int totalNegative = 0;
	int totalMatching = 0;
	int totalUnmatch = 0;
	int totalReviews = 0;
};

static void tokenize(string review, LinkedList& list) {
	string word;
	for (char c : review) {
		// Check if the character is a valid ASCII alphanumeric character
		if (isascii(c) && isalnum(c)) {
			word += tolower(c); // Convert to lowercase
		}
		else {
			// If we reach a non-alphanumeric character and have a valid word, insert it
			if (!word.empty()) {
				list.insertFront(word);
				word.clear(); // Clear the word after inserting
			}
		}
	}
	// Insert the last word if there's one remaining
	if (!word.empty()) {
		list.insertFront(word);
	}
}

int calculateSentimentScore(int positiveCount, int negativeCount) {
	int N = positiveCount + negativeCount;
	int rawScore = positiveCount - negativeCount;
	int minRawScore = -N;
	int maxRawScore = N;

	if (maxRawScore == minRawScore) return 3;

	float normalizedScore = float(rawScore - minRawScore) / (maxRawScore - minRawScore);
	return round(1 + (4 * normalizedScore));
}

void analyzeScore(int sentimentScore, int ratingGiven,Summary& summary) {
	string result = (sentimentScore != ratingGiven) ? "does not match" : "matches";
	string consistency = (sentimentScore != ratingGiven) ? "inconsistency" : "consistency";

	// Update summary based on sentiment score and user rating
	if (sentimentScore == ratingGiven) {
		summary.totalMatching++;
	}
	else {
		summary.totalUnmatch++;
	}

	switch (sentimentScore) {
	case 1:
	case 2:  // When the round score is 1-2
		summary.totalNegative++;
		break;  // Break ensures the next case doesn't execute

	case 3:
		summary.totalNeutral++;
		break;

	case 4:
	case 5:  // When the round score is 4-5
		summary.totalPositive++;
		break;

	default:
		// Handle unexpected values of roundScore
		break;
	}


	cout << "User's subjective evaluation " << result << " the sentiment score provided by the analysis. "
		<< "There is a " << consistency << " between the sentiment score generated by the analysis and the user's evaluation of the sentiment."
		<< endl << endl;
}

void displayCount(int reviewCount, int totalPositiveCount, int totalNegativeCount, LinkedList& accumulatedWordList) {
	cout << "Total Reviews Processed = " << reviewCount << endl;
	cout << "Total Count of Positive Words = " << totalPositiveCount << endl;
	cout << "Total Count of Negative Words = " << totalNegativeCount << endl;
	cout << "Full Word List (from all reviews, sorted by frequency):" << endl;
	accumulatedWordList.displayList();
}

void displayFinalSummary(const Summary& summary) {
	std::cout << "----------------------------------Final Summary----------------------------------" << endl;
	std::cout << "Total Positive Review       : " << summary.totalPositive << endl;
	std::cout << "Total Neutral Review        : " << summary.totalNeutral << endl;
	std::cout << "Total Negative Review       : " << summary.totalNegative << endl;
	std::cout << "Total Matching Review       : " << summary.totalMatching << endl;
	std::cout << "Total Unmatch Review        : " << summary.totalUnmatch << endl;
	std::cout << "Total Review                : " << summary.totalReviews << endl;


	// Calculate and display overall evaluation accuracy
	if (summary.totalReviews > 0) {
		double overallAccuracy = (static_cast<double>(summary.totalMatching) / summary.totalReviews) * 100;
		cout << fixed << setprecision(2); // Set precision for percentage display
		cout << "Overall Evaluation Accuracy  : " << overallAccuracy << "%" << std::endl;
	}
	else {
		std::cout << "Overall Evaluation Accuracy  : N/A" << std::endl;
	}
}


void processReviews(LinkedList& reviewsList, LinkedList& positiveList, LinkedList& negativeList, Summary& summary) {
	LinkedList wordList, accumulatedWordList;
	int totalPositiveCount = 0, totalNegativeCount = 0, reviewCount = 0;

	for (Node* currentReviewNode = reviewsList.getHead(); currentReviewNode != nullptr; currentReviewNode = currentReviewNode->nextAddress) {
		LinkedList foundPositiveList, foundNegativeList;
		int positiveCount = 0, negativeCount = 0;
		reviewCount++;

		cout << "Review " << reviewCount << ": " << currentReviewNode->review << endl << endl;

		tokenize(currentReviewNode->review, wordList);
		LinkedList foundList = reviewsList.search(wordList, positiveList, negativeList);

		for (WordNode* currentWord = foundList.getWordHead(); currentWord != nullptr; currentWord = currentWord->nextAddress) {
			if (positiveList.linearSearch(currentWord->word)) {
				foundPositiveList.checkDuped(currentWord->word);
				positiveCount++;
			}
			else {
				foundNegativeList.checkDuped(currentWord->word);
				negativeCount++;
			}
			accumulatedWordList.checkDuped(currentWord->word);
		}

		cout << positiveCount << " Positive words found:" << endl;
		foundPositiveList.displayList();

		cout << negativeCount << " Negative words found:" << endl;
		foundNegativeList.displayList();

		totalPositiveCount += positiveCount;
		totalNegativeCount += negativeCount;

		int sentimentScore = calculateSentimentScore(positiveCount, negativeCount);
		cout << "Sentiment Score (1-5) = " << sentimentScore << endl;
		cout << "Rating given by User =  " << currentReviewNode->rating << endl;
		analyzeScore(sentimentScore, stoi(currentReviewNode->rating), summary);

		wordList = LinkedList();
	}
	summary.totalReviews = reviewCount;	
	accumulatedWordList.sortByFrequency();
	displayCount(reviewCount, totalPositiveCount, totalNegativeCount, accumulatedWordList);
	displayFinalSummary(summary);

}



int main() {
	FileHandler fileHandler;
	LinkedList reviewsList, positiveList, negativeList;
	Summary summary;

	fileHandler.readReviewsFromCSV("tripadvisor_hotel_reviews.csv", reviewsList);
	fileHandler.readWordFromText("positive-words.txt", positiveList);
	fileHandler.readWordFromText("negative-words.txt", negativeList);

	auto startTime = high_resolution_clock::now();

	processReviews(reviewsList, positiveList, negativeList,summary);

	auto endTime = high_resolution_clock::now();
	auto duration = duration_cast<microseconds>(endTime - startTime);

	cout << "Time taken: " << duration.count() / 1'000'000 / 60 << " minutes and "
		<< (duration.count() / 1'000'000) % 60 << " seconds." << endl;

	return 0;
}




// Project1.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include "LinkedList.h"
#include "FileHandler.h"

using namespace std;

static void tokenize(string review, LinkedList& list) {
	string word = "";
	for (char c : review) {
		// Manually check if the character is alphanumeric
		if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
			// Manually convert to lowercase if it's an uppercase letter
			if (c >= 'A' && c <= 'Z') {
				c = c + 32; // Convert to lowercase by adding ASCII offset
			}
			word += c;
		}
		else {
			if (!word.empty()) {
				list.insertFront(word);
				word = "";
			}
		}
	}

	if (!word.empty()) {
		list.insertFront(word);
	}
}

int calculateSentimentScore(int positiveCount, int negativeCount) {
	int N = positiveCount + negativeCount;
	int rawScore = positiveCount - negativeCount;
	int minRawScore = -N;
	int maxRawScore = N;

	if (maxRawScore == minRawScore) return 3;

	float normalizedScore = float(rawScore - minRawScore) / (maxRawScore - minRawScore);
	return round(1.0f + (4.0f * normalizedScore));
}

void analyzeScore(int sentimentScore, int ratingGiven) {
	string result = (sentimentScore != ratingGiven) ? "does not match" : "matches";
	string consistency = (sentimentScore != ratingGiven) ? "inconsistency" : "consistency";

	cout << "User's subjective evaluation " << result << " the sentiment score provided by the analysis. "
		<< "There is a " << consistency << " between the sentiment score generated by the analysis and the user's evaluation of the sentiment."
		<< endl << endl;
}


int main()
{
	class FileHandler fileHandler;

	LinkedList reviewsList, positiveList, negativeList;
	fileHandler.readReviewsFromCSV("tripadvisor_hotel_reviews.csv", reviewsList);
	fileHandler.readWordFromText("positive-words.txt", positiveList);
	fileHandler.readWordFromText("negative-words.txt", negativeList);

	LinkedList wordList;
	LinkedList foundPositiveList;
	LinkedList foundNegativeList;
	LinkedList accumulatedWordList; // This will accumulate words across all reviews
	int positiveCount = 0;
	int negativeCount = 0;
	int totalPositiveCount = 0;
	int totalNegativeCount = 0;
	int reviewCount = 1;

	Node* currentReviewNode = reviewsList.getHead();

	// Processing each review and accumulating the total counts
	while (currentReviewNode != nullptr) {
		cout << "Review " << reviewCount << ": " << currentReviewNode->review << endl << endl;

		// Tokenize the current review
		tokenize(currentReviewNode->review, wordList);
		LinkedList foundList = reviewsList.search(wordList, positiveList, negativeList);
		foundList.sortByPosNeg(positiveList, negativeList);

		// Accumulate words into a single list
		WordNode* currentWord = foundList.getWordHead();
		
		// Classify words into positive and negative lists
		currentWord = foundList.getWordHead();
		while (currentWord != nullptr) {
			if (positiveList.contains(currentWord->word)) {
				foundPositiveList.insertFront(currentWord->word);
			}
			else if (negativeList.contains(currentWord->word)) {
				foundNegativeList.insertFront(currentWord->word);
			}
			accumulatedWordList.insertFront(currentWord->word);
			currentWord = currentWord->nextAddress;
		}

		// Display positive and negative words found
		positiveCount = foundPositiveList.getSize();
		cout << positiveCount << " Positive words found:" << endl;
		foundPositiveList.removeDuplicates();
		foundPositiveList.displayList();

		negativeCount = foundNegativeList.getSize();
		cout << negativeCount << " Negative words found:" << endl;
		foundNegativeList.removeDuplicates();
		foundNegativeList.displayList();

		// Accumulate total positive and negative word counts
		totalPositiveCount += positiveCount;
		totalNegativeCount += negativeCount;

		// Calculate and display sentiment score
		int sentimentScore = calculateSentimentScore(positiveCount, negativeCount);
		cout << "Sentiment Score (1-5) = " << sentimentScore << endl;
		cout << "Rating given by User =  " << currentReviewNode->rating << endl;
		analyzeScore(sentimentScore, stoi(currentReviewNode->rating));

		// Reset lists for the next review
		foundPositiveList = LinkedList();
		foundNegativeList = LinkedList();
		wordList = LinkedList();
		reviewCount++;
		currentReviewNode = currentReviewNode->nextAddress;
	}

	// Sort the accumulated word list by frequency
	accumulatedWordList.sortByFrequency();

	// Display overall summary
	cout << "Total Reviews Processed = " << reviewCount - 1 << endl;
	cout << "Total Count of Positive Words = " << totalPositiveCount << endl;
	cout << "Total Count of Negative Words = " << totalNegativeCount << endl;

	// Display the accumulated full word list (sorted by frequency)
	cout << "Full Word List (from all reviews, sorted by frequency):" << endl;
	accumulatedWordList.removeDuplicates();
	accumulatedWordList.displayList();


}



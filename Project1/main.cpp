// Project1.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <chrono>
#include <iomanip>
#include "LinkedList.h"
#include "Timer.h"
#include "FileHandler.h"


struct Summary {
    int totalPositive = 0;
    int totalNeutral = 0;
    int totalNegative = 0;
    int totalMatching = 0;
    int totalUnmatch = 0;
    int totalReviews = 0;
};

static void tokenize(string review, LinkedList& list) {
    string word = "";
    for (char c : review) {
        // check alphanumeric
        if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
            // convert to lowercase 
            if (c >= 'A' && c <= 'Z') {
                c = c + 32;
            }
            word += c;
        }
        else {
            if (!word.empty()) {
                list.insertFront(word);
                word = "";
            }
        }
    }

    if (!word.empty()) {
        list.insertFront(word);
    }
}

static int calculateSentimentScore(int positiveCount, int negativeCount) {
    int N = positiveCount + negativeCount;
    int rawScore = positiveCount - negativeCount;
    int minRawScore = -N;
    int maxRawScore = N;

    if (maxRawScore == minRawScore) return 3;

    float normalizedScore = float(rawScore - minRawScore) / (maxRawScore - minRawScore);
    return round(1.0f + (4.0f * normalizedScore));
}

// compare sentimental score and the rating given
static void analyzeScore(int sentimentScore, int ratingGiven, Summary& summary) {
    string result = (sentimentScore != ratingGiven) ? "does not match" : "matches";
    string consistency = (sentimentScore != ratingGiven) ? "inconsistency" : "consistency";

    // Update summary based on sentiment score and user rating
    if (sentimentScore == ratingGiven) {
        summary.totalMatching++;
    }
    else {
        summary.totalUnmatch++;
    }

    switch (sentimentScore) {
    case 1:
    case 2:  // When the round score is 1-2
        summary.totalNegative++;
        break;  // Break ensures the next case doesn't execute

    case 3:
        summary.totalNeutral++;
        break;

    case 4:
    case 5:  // When the round score is 4-5
        summary.totalPositive++;
        break;

    default:
        // Handle unexpected values of roundScore
        break;
    }


    cout << "User's subjective evaluation " << result << " the sentiment score provided by the analysis. "
        << "There is a " << consistency << " between the sentiment score generated by the analysis and the user's evaluation of the sentiment."
        << endl << endl;
}

static void displayCount(int reviewCount, int totalPositiveCount, int totalNegativeCount, LinkedList& accumulatedWordList) {
    cout << "Total Reviews Processed = " << reviewCount << endl;
    cout << "Total Count of Positive Words = " << totalPositiveCount << endl;
    cout << "Total Count of Negative Words = " << totalNegativeCount << endl;
    cout << "Full Word List (from all reviews, sorted by frequency):" << endl;
    accumulatedWordList.displayList();
}

static void displayFinalSummary(const Summary& summary) {
    std::cout << "----------------------------------Final Summary----------------------------------" << endl;
    std::cout << "Total Positive Review       : " << summary.totalPositive << endl;
    std::cout << "Total Neutral Review        : " << summary.totalNeutral << endl;
    std::cout << "Total Negative Review       : " << summary.totalNegative << endl;
    std::cout << "Total Matching Review       : " << summary.totalMatching << endl;
    std::cout << "Total Unmatch Review        : " << summary.totalUnmatch << endl;
    std::cout << "Total Review                : " << summary.totalReviews << endl;


    // Calculate and display overall evaluation accuracy
    if (summary.totalReviews > 0) {
		double totalMatched = summary.totalMatching * 1.0;
		double allReviews = summary.totalReviews * 1.0;
        double overallAccuracy = (totalMatched / allReviews) * 100.0;
        cout << fixed << setprecision(2); // Set precision for percentage display
        cout << "Overall Evaluation Accuracy  : " << overallAccuracy << "%" << std::endl;
    }
    else {
        std::cout << "Overall Evaluation Accuracy  : N/A" << std::endl;
    }
}

// Function pointer type for search functions
using SearchFunction = bool (LinkedList::*)(string);
using SortFunction = void (LinkedList::*)();

// ***************************************** //
//                                           //
// WONG YI ZUN (merge sort & linear search)  //
//                                           //
// AU YIK HOE (quick sort & binary search)   //
//                                           //
// ***************************************** //
static void processReviews(LinkedList& reviewsList, LinkedList& positiveList, LinkedList& negativeList, Summary& summary, SearchFunction searchFunction, 
    bool searchType, SortFunction sortFunction, Timer& searchTimer, Timer& sortTimer) {
	LinkedList accumulatedWordList;
	int totalPositiveCount = 0, totalNegativeCount = 0, reviewCount = 0;

	for (Node* currentReviewNode = reviewsList.getHead(); currentReviewNode != nullptr; currentReviewNode = currentReviewNode->nextAddress) {
        LinkedList wordList;
		int positiveCount = 0, negativeCount = 0;

        cout << string(120, '=') << endl;
		cout << "Review " << reviewCount << ": " << currentReviewNode->review << endl << endl;

		tokenize(currentReviewNode->review, wordList);

        sortTimer.start();
        (wordList.*sortFunction)();
        sortTimer.stop();

        // Timer for search algorithm
        searchTimer.start();

        for (WordNode* currentWord = wordList.getWordHead(); currentWord != nullptr; currentWord = currentWord->nextAddress) {
            if ((positiveList.*searchFunction)(currentWord->word)) {
                accumulatedWordList.checkDuped(currentWord->word);
                totalPositiveCount++;
                positiveCount++;
            }
            else if ((negativeList.*searchFunction)(currentWord->word)) {
                accumulatedWordList.checkDuped(currentWord->word);
                totalNegativeCount++;
                negativeCount++;
            }
        }

        searchTimer.stop();
		cout << "Time taken for search: " << searchTimer.getInterval().count() / 1'000'000.0 << " seconds." << endl;

		cout << positiveCount << " Positive words found:" << endl;
		positiveList.displayList();

		cout << negativeCount << " Negative words found:" << endl;
		negativeList.displayList();

		int sentimentScore = calculateSentimentScore(positiveCount, negativeCount);
		cout << "Sentiment Score (1-5) = " << sentimentScore << endl;
		cout << "Rating given by User =  " << currentReviewNode->rating << endl;
		analyzeScore(sentimentScore, stoi(currentReviewNode->rating), summary);

        positiveList.resetFrequencies();
        negativeList.resetFrequencies();
        reviewCount++;

        cout << string(120, '=') << endl;
	}
	summary.totalReviews = reviewCount;

	// Timer for sort algorithm
    sortTimer.start();

    (accumulatedWordList.*sortFunction)();

    sortTimer.stop();

	displayCount(reviewCount, totalPositiveCount, totalNegativeCount, accumulatedWordList);

    if (searchType) {
        accumulatedWordList.jumpFindMax();
        accumulatedWordList.jumpFindMin();
    }
    else {
        accumulatedWordList.binaryFindMax();
        accumulatedWordList.binaryFindMin();
    }

	displayFinalSummary(summary);
    cout << fixed << setprecision(4);
    cout << "Time taken for all search: " << searchTimer.totalTime().count() / 1'000'000.0 << " seconds." << endl;
    cout << "Time taken for sorting: " << sortTimer.getInterval().count() / 1'000.0 << " milliseconds." << endl;
}

// retrieve review
static void analyzeReview(Node* review, LinkedList& positiveList, LinkedList& negativeList, Summary& summary, 
    SearchFunction searchFunction, bool searchType, SortFunction sortFunction) {
    LinkedList accumulatedWordList;
    int totalPositiveCount = 0, totalNegativeCount = 0, reviewCount = 0;
    LinkedList wordList;
    int positiveCount = 0, negativeCount = 0;

    cout << string(120, '=') << endl;
    cout << "Review: " << review->review << endl << endl;

    tokenize(review->review, wordList);
    (wordList.*sortFunction)();

    for (WordNode* currentWord = wordList.getWordHead(); currentWord != nullptr; currentWord = currentWord->nextAddress) {
        if ((positiveList.*searchFunction)(currentWord->word)) {
            accumulatedWordList.checkDuped(currentWord->word);
            totalPositiveCount++;
            positiveCount++;
        }
        else if ((negativeList.*searchFunction)(currentWord->word)) {
            accumulatedWordList.checkDuped(currentWord->word);
            totalNegativeCount++;
            negativeCount++;
        }
    }
    cout << positiveCount << " Positive words found:" << endl;
    positiveList.displayList();

    cout << negativeCount << " Negative words found:" << endl;
    negativeList.displayList();

    int sentimentScore = calculateSentimentScore(positiveCount, negativeCount);
    cout << "Sentiment Score (1-5) = " << sentimentScore << endl;
    cout << "Rating given by User =  " << review->rating << endl;
    analyzeScore(sentimentScore, stoi(review->rating), summary);

    positiveList.resetFrequencies();
    negativeList.resetFrequencies();

    cout << string(120, '=') << endl;

    summary.totalReviews = reviewCount;

    (accumulatedWordList.*sortFunction)();

    displayCount(reviewCount, totalPositiveCount, totalNegativeCount, accumulatedWordList);

    if (searchType) {
        accumulatedWordList.jumpFindMax();
        accumulatedWordList.jumpFindMin();
    }
    else {
        accumulatedWordList.binaryFindMax();
        accumulatedWordList.binaryFindMin();
    }
}

// Detail Algorithm Performance Analytics
void displayAlgoAnalytics(Timer& searchTimer, Timer& sortTimer, int searchAlgoChoice, int sortAlgoChoice) {
    string search, sort;

    if (searchAlgoChoice == 1) {
        search = "BINARY SEARCH";
    }
    else {
        search = "JUMP SEARCH";
    }

    if (sortAlgoChoice == 1) {
        sort = "QUICK SORT";
    }
    else {
        sort = "MERGE SORT";
    }

    cout << string(20, '*') << " Detail Algorithm Time Analytics " << string(20, '*') << endl;

    // time analytics of search algorithm
    cout << string(10, '=') << string(5, ' ') << search << string(5, ' ') << string(10, '=') << endl;
    cout << "Total time\t:\t" << searchTimer.totalTime().count() / 1'000'000.0 << " seconds" << endl;
    cout << "Average time\t:\t" << searchTimer.averageRunTime().count() / 1'000'000.0 << " seconds" << endl;
    cout << "Max time\t:\t" << searchTimer.maxRunTime().count() / 1'000'000.0 << " seconds" << endl;
    cout << "Min time\t:\t" << searchTimer.minRunTime().count() / 1'000'000.0 << " seconds" << endl;
    cout << "Total intervals\t:\t" << searchTimer.getCount() << " times" << endl;

    cout << endl << endl;

    // time analytics of sort algorithm
    cout << string(10, '=') << string(5, ' ') << sort << string(5, ' ') << string(10, '=') << endl;
    cout << "Total time\t:\t" << sortTimer.totalTime().count() / 1'000.0 << " milliseconds" << endl;
    cout << "Average time\t:\t" << sortTimer.averageRunTime().count() / 1'000.0 << " milliseconds" << endl;
    cout << "Max time\t:\t" << sortTimer.maxRunTime().count() / 1'000.0 << " milliseconds" << endl;
    cout << "Min time\t:\t" << sortTimer.minRunTime().count() / 1'000.0 << " milliseconds" << endl;
    cout << "Total intervals\t:\t" << sortTimer.getCount() << " times" << endl;
}

// Display algorithm option
void displayAlgoSelectionMenu(int& choice, int& sortChoice, bool& searchFlag, SearchFunction& searchFunction, SortFunction& sortFunction) {
    // Searching algorithm selection
    cout << "Choose Search Algorithm:\n1. Binary Search\n2. Jump Search\n";
    cin >> choice;

    if (choice == 1) {
        searchFunction = &LinkedList::binarySearch;
        searchFlag = 0;
    }
    else if (choice == 2) {
        searchFunction = &LinkedList::jumpSearch;
        searchFlag = 1;
    }
    else {
        cout << "Invalid choice, defaulting to Linear Search." << endl;
        searchFunction = &LinkedList::jumpSearch;
        searchFlag = 1;
    }

    cout << endl;

    // Sorting alogorithm selection
    cout << "Choose Sort Algorithm:\n1. Quick Sort\n2. Merge Sort\n";
    cin >> sortChoice;

    if (sortChoice == 1) {
        sortFunction = &LinkedList::quickSort;
    }
    else if (sortChoice == 2) {
        sortFunction = &LinkedList::mergeSortByFrequency;
    }
    else {
        cout << "Invalid choice, defaulting to Merge Sort." << endl;
        sortFunction = &LinkedList::mergeSortByFrequency;
    }

    cout << endl;
}

void systemOperations(int& choice) {
    cout << "Please choose an operation below: " << endl << endl;
    cout << "1. Analyze All Reviews" << endl <<
        "2. Retrieve review" << endl <<
        "3. Analyze new review" << endl <<
        "4. Exit" << endl << endl;
    cin >> choice;

    while (choice != 1 && choice != 2 && choice != 3 && choice != 4) {
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
        cout << "Please enter the given option numbers" << endl << "> ";
        cin >> choice;
    }
}

void executeOperation(int operationChoice, LinkedList& reviewsList, LinkedList& positiveList, LinkedList& negativeList, bool& searchFlag, 
    SearchFunction& searchFunction, SortFunction& sortFunction, int searchAlgoChoice, int sortAlgoChoice) {
    Timer runTimer, searchTimer, sortTimer;
    Summary summary;
    Node* node;
    string review;

    switch (operationChoice)
    {
    case 1:
        // Analyze all reviews
        runTimer.start();
        processReviews(reviewsList, positiveList, negativeList, summary, searchFunction, searchFlag, sortFunction, searchTimer, sortTimer);
        runTimer.stop();

        cout << "Time taken: " << runTimer.totalTime().count() / 1'000'000 / 60 << " minutes and "
            << (runTimer.totalTime().count() / 1'000'000) % 60 << " seconds." << endl;
        
        cout << endl;

        // Detail
        displayAlgoAnalytics(searchTimer, sortTimer, searchAlgoChoice, sortAlgoChoice);
        break;
    case 2:
        // Retreive specific review
        int id;
        cout << "Enter review ID > ";
        cin >> id;
        node = reviewsList.getReview(id);
        if (node != nullptr) {
            Summary sum;
            analyzeReview(node, positiveList, negativeList, summary, searchFunction, searchFlag, sortFunction);
        }
        else {
            cout << "Review not found!" << endl;
        }
        break;

    case 3:
        int rating;
        cout << "Enter review: ";
        cin.ignore();
        getline(cin, review);
        cout << "Enter rating: ";
        cin >> rating;

        while (cin.fail() || rating < 1 || rating > 5 || review.length() < 1) {
            cout << "Please enter valid review and rating." << endl;
            cout << "Enter review: ";
            cin.ignore();
            getline(cin, review);
            cout << "Enter rating: ";
            cin >> rating;
        }

        node = new Node(review, to_string(rating));
        analyzeReview(node, positiveList, negativeList, summary, searchFunction, searchFlag, sortFunction);
        break;

    default:
        cout << string(20, '=') << "\tPROGRAM TERMINATED\t" << string(20, '=') << endl;
        break;
    }
}

int main() {
	LinkedList reviewsList, positiveList, negativeList;

	readReviewsFromCSV("tripadvisor_hotel_reviews.csv", reviewsList);
	readWordFromText("positive-words.txt", positiveList);
	readWordFromText("negative-words.txt", negativeList);

    int choice, sortChoice;
    bool searchFlag;
    SearchFunction searchFunction;
    SortFunction sortFunction;

    // Program initiation
    // Choose searching and sorting algorithms
    displayAlgoSelectionMenu(choice, sortChoice, searchFlag, searchFunction, sortFunction);

    // System operations menu
    int operationChoice;
    systemOperations(operationChoice);
    
    // Operation execution
    executeOperation(operationChoice, reviewsList, positiveList, negativeList, 
        searchFlag, searchFunction, sortFunction, choice, sortChoice);

	return 0;
}




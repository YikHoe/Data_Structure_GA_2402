// Project1.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include "LinkedList.h"
#include "FileHandler.h"
#include <chrono>

using namespace std;
using namespace std::chrono;


static void tokenize(string review, LinkedList& list) {
	string word;
	for (char c : review) {
		// Check if the character is a valid ASCII alphanumeric character
		if (isascii(c) && isalnum(c)) {
			word += tolower(c); // Convert to lowercase
		}
		else {
			// If we reach a non-alphanumeric character and have a valid word, insert it
			if (!word.empty()) {
				list.insertFront(word);
				word.clear(); // Clear the word after inserting
			}
		}
	}
	// Insert the last word if there's one remaining
	if (!word.empty()) {
		list.insertFront(word);
	}
}

int calculateSentimentScore(int positiveCount, int negativeCount) {
	int N = positiveCount + negativeCount;
	int rawScore = positiveCount - negativeCount;
	int minRawScore = -N;
	int maxRawScore = N;

	if (maxRawScore == minRawScore) return 3;

	float normalizedScore = float(rawScore - minRawScore) / (maxRawScore - minRawScore);
	return round(1 + (4 * normalizedScore));
}

void analyzeScore(int sentimentScore, int ratingGiven) {
	string result = (sentimentScore != ratingGiven) ? "does not match" : "matches";
	string consistency = (sentimentScore != ratingGiven) ? "inconsistency" : "consistency";

	cout << "User's subjective evaluation " << result << " the sentiment score provided by the analysis. "
		<< "There is a " << consistency << " between the sentiment score generated by the analysis and the user's evaluation of the sentiment."
		<< endl << endl;
}


int main()
{
	class FileHandler fileHandler;

	LinkedList reviewsList, positiveList, negativeList;
	fileHandler.readReviewsFromCSV("tripadvisor_hotel_reviews.csv", reviewsList);
	fileHandler.readWordFromText("positive-words.txt", positiveList);
	fileHandler.readWordFromText("negative-words.txt", negativeList);

	LinkedList wordList;
	LinkedList accumulatedWordList; // This will accumulate words across all reviews

	int totalPositiveCount = 0;
	int totalNegativeCount = 0;
	int reviewCount = 1;

	auto startSort = high_resolution_clock::now();


	Node* currentReviewNode = reviewsList.getHead();

	// Processing each review and accumulating the total counts
	while (currentReviewNode != nullptr) {
		LinkedList foundPositiveList;
		LinkedList foundNegativeList;
		int positiveCount = 0;
		int negativeCount = 0;

		cout << "Review " << reviewCount << ": " << currentReviewNode->review << endl << endl;

		// Tokenize the current review
		tokenize(currentReviewNode->review, wordList);
		LinkedList foundList = reviewsList.search(wordList, positiveList, negativeList);

		// Accumulate words into a single list
		WordNode* currentWord = foundList.getWordHead();

		// Classify words into positive and negative lists
		currentWord = foundList.getWordHead();
		while (currentWord != nullptr) {
			if (positiveList.linearSearch(currentWord->word)) {
				foundPositiveList.checkDuped(currentWord->word);
				positiveCount++;
			}
			else {
				foundNegativeList.checkDuped(currentWord->word);
				negativeCount++;
			}
			accumulatedWordList.checkDuped(currentWord->word);
			currentWord = currentWord->nextAddress;
		}

		// Display positive and negative words found
		cout << positiveCount << " Positive words found:" << endl;
		foundPositiveList.displayList();

		cout << negativeCount << " Negative words found:" << endl;
		foundNegativeList.displayList();

		// Accumulate total positive and negative word counts
		totalPositiveCount += positiveCount;
		totalNegativeCount += negativeCount;

		// Calculate and display sentiment score
		int sentimentScore = calculateSentimentScore(positiveCount, negativeCount);
		cout << "Sentiment Score (1-5) = " << sentimentScore << endl;
		cout << "Rating given by User =  " << currentReviewNode->rating << endl;
		analyzeScore(sentimentScore, stoi(currentReviewNode->rating));

		wordList = LinkedList();
		reviewCount++;
		currentReviewNode = currentReviewNode->nextAddress;
	}

	// Sort the accumulated word list by frequency
	accumulatedWordList.sortByFrequency();

	// Display overall summary
	cout << "Total Reviews Processed = " << reviewCount - 1 << endl;
	cout << "Total Count of Positive Words = " << totalPositiveCount << endl;
	cout << "Total Count of Negative Words = " << totalNegativeCount << endl;

	// Display the accumulated full word list (sorted by frequency)
	cout << "Full Word List (from all reviews, sorted by frequency):" << endl;
	accumulatedWordList.displayList();

	auto stopSort = high_resolution_clock::now();
	// Calculate the duration in microseconds
	auto duration = duration_cast<microseconds>(stopSort - startSort).count();

	// Convert duration to minutes and seconds
	long minutes = duration / 1'000'000 / 60; // Convert microseconds to minutes
	long seconds = (duration / 1'000'000) % 60; // Remaining seconds after minutes

	cout << "Time taken to sort: " << minutes << " minutes and " << seconds << " seconds." << std::endl;


}


